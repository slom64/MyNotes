
> [!Question] 
> if we don't do any object merging there would be no prototype pollution. the most important sinks for this are 
lodash(), jquery(), merge(). is there any other things?

That is a very accurate observation. Prototype Pollution is essentially a **logic flaw** in how data is handled. If you never dynamically assign properties to an object based on user input, the "sink" never exists, and the "source" (the URL) remains harmless.

While `lodash`, `jQuery`, and various `merge` or `clone` utilities are the most famous culprits, the landscape of "sinks" is broader. Here is a detailed look at other common triggers and gadgets.

---

|**Sink Type**|**Examples / Libraries**|**Dangerous Code Pattern**|
|---|---|---|
|**Object Merging**|`jQuery.extend()`, `lodash.merge()`|`merge(target, source)`|
|**Object Cloning**|`lodash.cloneDeep()`|`newObj = clone(input)`|
|**Path Setters**|`dot-object`, `object-path`, `mpath`|`set(obj, "__proto__.polluted", true)`|
|**URL Parsing**|`qs`, `query-string` (older versions)|`qs.parse(urlQueryString)`|
|**Direct Loop**|Custom `for...in` loops|`for(let k in params) { obj[k] = params[k] }`|
|**JSON Parsing**|`JSON.parse()` + Merge|`merge(obj, JSON.parse(userInput))`|

## 1. Other Common "Sinks" (Beyond Merge)

### A. Deep Object Setters

Libraries like dot-object, mpath, or object-path allow developers to set values using a string path (e.g., set(obj, "user.name", "John")).

If the path is user-controlled, an attacker can pass:

```
?path=__proto__.isAdmin&value=true
```

### B. Path/Query Parsers

Some older or custom-built URL query parsers automatically "nest" objects. If you send `?a[b]=c`, it creates `{a: {b: 'c'}}`. If the parser isn't hardened, sending `?__proto__[polluted]=true` will cause the parser itself to pollute the global `Object.prototype` while it's trying to build the parameters object.
- **Examples:** Older versions of `qs` (Query String) or `fast-querystring`.

### C. JSON.parse() Logic

When an application takes a JSON string and uses a custom "reviver" or a follow-up merge function to process it, pollution can occur.

```js
let userData = JSON.parse('{"__proto__": {"admin": true}}');
// If this object is later merged into a base config, the prototype is hit.
```

---

## 2. Common "Gadgets" to Look For

A **Gadget** is a piece of existing code in the application that _unintentionally_ uses the property you just polluted.

| **Gadget Type**           | **What to look for in the JS Source** |
| ------------------------- | ------------------------------------- |
| **Configuration Objects** | `let options = config`                |
| **Script Loading**        | `script.src = settings.url`           |
| **HTML Injection**        | `element.innerHTML = user.bio`        |
| **Fetch/XHR**             | `fetch(url, {method: options.method`  |

---

## 3. Investigating Sinks with PowerShell

Since you are looking for things beyond the standard `merge` libraries, you can use PowerShell to find "custom" merge logic or dangerous property assignments in the codebase.

### Searching for "Path Setter" logic

Developers often write their own "set" functions. This script looks for functions that take a "path" and a "value":

PowerShell

```
# Search for custom 'set' or 'path' functions that might be vulnerable
Get-ChildItem -Recurse -Filter "*.js" | Select-String -Pattern "function\s+\w*set\w*\(.*path|key" | Select-Object FileName, LineNumber, Line
```

### Searching for "Defaults" Gadgets

This script looks for the "OR" pattern (`||`) which is the most common way a gadget is triggered (it looks for a property, finds it missing on the instance, and falls back to your polluted prototype):

PowerShell

```
# Look for places where code falls back to a default value
# This identifies potential GADGETS.
Get-ChildItem -Recurse -Filter "*.js" | Select-String -Pattern "let\s+\w+\s*=\s*\w+\.\w+\s*\|\|"
```

---

## 4. The "No Merging" Exception

While you said "if we don't do any object merging there would be no prototype pollution," there is one rare exception: **Direct Property Assignment via URL.**

If a developer does something like this:

JavaScript

```
const params = new URLSearchParams(window.location.search);
const theme = {};
for (const [key, value] of params) {
    theme[key] = value; // DANGEROUS: Direct assignment from URL keys
}
```

In this case, there is no "merge" library involved, just a simple loop. If the URL contains `?__proto__=...`, the `theme` objectâ€™s prototype is polluted immediately.

**Next Step:** Would you like to see how to use **Burp Suite's "Search"** function (or a PowerShell equivalent) to find these specific "Gadget" code patterns in a large site's JavaScript files?