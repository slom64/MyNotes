
> [!Question]
> how do websockets do session management, how does the server knows each request belongs to who.

WebSockets handle session management differently than standard HTTP because they are **stateful** connections.1 While a standard web app treats every request as a new "meeting," a WebSocket is like a single, long "phone call."

Here is how the server keeps track of who is on the other end of that call.

---
### 1. The Handshake (The HTTP Phase)

A WebSocket doesn't start as a WebSocket. It begins as a standard **HTTP GET request** with an `Upgrade: websocket` header.2

Because this initial handshake is just a regular HTTP request, the browser follows all standard rules:
- It automatically attaches the **Session Cookies** for that domain.3    
- The server receives these cookies and parses them just like it would for a normal page load.4
---
### 2. Connection Upgrade and Context Mapping

Once the server validates the session cookie during the handshake, it accepts the connection. At this point, the server creates a **Mapping** in its memory (or a database like Redis).

It links the specific **TCP Socket ID** to the **User ID** found in the session cookie.

---
### 3. The Stateful Phase (The "Phone Call")

Once the handshake is complete, the HTTP protocol is "switched off." The cookies are **never sent again** for the life of that connection.
- **How the server knows:** When a message arrives at the server, the server looks at the underlying **TCP connection**.
- Because that specific connection was already "authenticated" during the handshake, the server knows that any data coming through that specific pipe belongs to `User A`.

---
### Comparison: HTTP vs. WebSocket Session Management

| **Feature**         | **HTTP (Stateless)**                                | **WebSocket (Stateful)**                                |
| ------------------- | --------------------------------------------------- | ------------------------------------------------------- |
| **Authentication**  | Every request must include a Cookie/Token.          | Only the **initial handshake** needs a Cookie/Token.    |
| **Server Overhead** | High (must parse and verify cookies every time).    | Low (checks the mapping once, then trusts the pipe).    |
| **Expiration**      | Session ends when the cookie expires or is deleted. | Session ends when the TCP connection is closed/dropped. |

---
### The Security Risk: Cross-Site WebSocket Hijacking (CSWH)

This is exactly why WebSockets are vulnerable to CSRF-like attacks.
1. A victim visits `attacker.com`.
2. `attacker.com` runs JavaScript that tries to connect to `vulnerable-bank.com/chat`.
3. The browser sends the victim's `vulnerable-bank.com` cookies automatically during the handshake.
4. The server sees the valid cookie and "locks in" the connection to the victim's account.    
5. The attacker now has a permanent, authenticated "pipe" to the victim's account.
