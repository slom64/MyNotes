## SameSite Bypasses
- **Bypassing SameSite Lax restrictions using GET requests**. You send a GET request, but you add specific things so that the backend thinks you have used POST instead of GET. But you have used GET.
- **Bypassing SameSite restrictions using on-site gadgets** (open-redirect).
- **Bypassing SameSite restrictions via vulnerable sibling domains**.(Reflected-xss, Open-redirect)
- **Bypassing SameSite Lax restrictions with newly issued cookies**.
Refere to [[SameSite Cookie]] to understand what is Samesite. But in nutshell, In `Lax` restriction the browser will add the user cookie if 2 conditions are met:
1. The request is GET Method.
2. We used top-level navigation function. Ex, click (Things that most probably user did intentionally).

---
### Bypassing SameSite Lax restrictions using GET requests

`Method spoofing`: Is a way to manipulate the http method. So, We can make the browser do GET and by adding addtitional paramters we can trick the backend to think we have used other method like POST. This is useful in CSRF attacks where GET method can include the user cookies in LAX restriction, and if the backend expect another http method like POST we can tamper this http method.

In practice, servers aren't always fussy about whether they receive a `GET` or `POST` request to a given endpoint, even those that are expecting a form submission. If they also use `Lax` restrictions for their session cookies, either explicitly or due to the browser default, you may still be able to perform a CSRF attack by eliciting a `GET` request from the victim's browser.

As long as the request involves a top-level navigation, the browser will still include the victim's session cookie. The following is one of the simplest approaches to launching such an attack:

```js
// Here the browser send GET request, but the backend receive the request and thinks its POST.
<script> 
	document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&_method=POST'; 
</script>
```

Even if an ordinary `GET` request isn't allowed, some frameworks provide ways of overriding the method specified in the request line. For example, Symfony supports the `_method` parameter in forms, which takes precedence over the normal method for routing purposes:

```html
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST"> 
	<input type="hidden" name="_method" value="GET"> 
	<input type="hidden" name="recipient" value="hacker"> 
</form>
```

Other frameworks support a variety of similar parameters.
#### Laravel (PHP)
Laravel uses the same convention as Rails and Symfony. It looks for a `_method` field.
- **The Exploit:** If you find a route defined as `Route::post('/user/delete', ...)`, Laravelâ€™s middleware will process the request if you send: 
```
https://vulnerable-site.com/user/delete?_method=POST&id=123
```
#### Express.js (Node.js)
In Express, developers often use a middleware called `method-override`. It is highly configurable, meaning the "gadget" could be anything the developer chose. Common configurations look for
- **Query parameter:** `?_method=DELETE`
- **Header:** `X-HTTP-Method-Override`

| **Framework**      | **Parameter/Method**     | **Common Usage**                       |
| ------------------ | ------------------------ | -------------------------------------- |
| **Symfony**        | `_method`                | Form hidden input or Query String      |
| **Ruby on Rails**  | `_method`                | Form hidden input or Query String      |
| **Laravel**        | `_method`                | Form hidden input or Query String      |
| **Spring**         | `_method`                | Needs `HiddenHttpMethodFilter` enabled |
| **Generic/Custom** | `X-HTTP-Method-Override` | Usually an HTTP Header                 |

---
### Bypassing SameSite restrictions using on-site gadgets

If a cookie is set with the `SameSite=Strict` attribute, browsers won't include it in any cross-site requests. You may be able to get around this limitation if you can find a gadget that results in a secondary request within the same site.

One possible gadget is a client-side redirect that dynamically constructs the redirection target using attacker-controllable input like URL parameters. For some examples [DOM-based open redirection](https://portswigger.net/web-security/dom-based/open-redirection).

As far as browsers are concerned, these client-side redirects aren't really redirects at all; the resulting request is just treated as an ordinary, standalone request. Most importantly, this is a same-site request and, as such, will include all cookies related to the site, regardless of any restrictions that are in place.

If you can manipulate this gadget to elicit a malicious secondary request, this can enable you to bypass any SameSite cookie restrictions completely.

> [!NOTE]
> The equivalent attack is not possible with server-side redirects. In this case, browsers recognize that the request to follow the redirect resulted from a cross-site request initially, so they still apply the appropriate cookie restrictions.

```html
<!-- The website has open Redirect, and we was able to modify the email using GET request. So we used open redirect to make browser include the user cookie. Even if the endpoint accepts only POST, we can use _method=POST to the backend accepts the request as POST request even if we made it using GET request  -->
<script>
      document.location = "https://0a7e00ee04792ac681c57adf00aa0081.web-security-academy.net/post/comment/confirmation?postId=../my-account/change-email%3femail=asdasdffas%40gmail.com%26submit=1";
</script>
```

---
### Bypassing SameSite restrictions via vulnerable sibling domains

Whether you're testing someone else's website or trying to secure your own, it's essential to keep in mind that a request can still be same-site even if it's issued cross-origin.

Make sure you thoroughly audit all of the available attack surface, including any sibling domains. In particular, vulnerabilities that enable you to elicit an arbitrary secondary request, such as XSS, can compromise site-based defenses completely, exposing all of the site's domains to cross-site attacks.

In addition to classic CSRF, don't forget that if the target website supports WebSockets, this functionality might be vulnerable to cross-site WebSocket hijacking (CSWSH), which is essentially just a CSRF attack targeting a WebSocket handshake. For more details, see our topic on [WebSocket vulnerabilities](https://portswigger.net/web-security/websockets).

---
### Bypassing SameSite Lax restrictions with newly issued cookies

Refere to [[Lax Weakness]] for more explanation.

Cookies with `Lax` SameSite restrictions aren't normally sent in any cross-site `POST` requests, but there are some exceptions.

As mentioned earlier, if a website doesn't include a `SameSite` attribute when setting a cookie, Chrome automatically applies `Lax` restrictions by default. However, to avoid breaking single sign-on (SSO) mechanisms, it doesn't actually enforce these restrictions for the first 120 seconds on top-level `POST` requests. As a result, there is a two-minute window in which users may be susceptible to cross-site attacks.

> [!NOTE]
> This two-minute window does not apply to cookies that were explicitly set with the `SameSite=Lax` attribute.

It's somewhat impractical to try timing the attack to fall within this short window. On the other hand, if you can find a gadget on the site that enables you to force the victim to be issued a new session cookie, you can preemptively refresh their cookie before following up with the main attack. For example, completing an OAuth-based login flow may result in a new session each time as the OAuth service doesn't necessarily know whether the user is still logged in to the target site.

To trigger the cookie refresh without the victim having to manually log in again, you need to use a top-level navigation, which ensures that the cookies associated with their current OAuth session are included. This poses an additional challenge because you then need to redirect the user back to your site so that you can launch the CSRF attack.

Alternatively, you can trigger the cookie refresh from a new tab so the browser doesn't leave the page before you're able to deliver the final attack. A minor snag with this approach is that browsers block popup tabs unless they're opened via a manual interaction. For example, the following popup will be blocked by the browser by default:

```js
window.open('https://vulnerable-website.com/login/sso');
```

To get around this, you can wrap the statement in an `onclick` event handler as follows:

```js
window.onclick = () => {
	window.open('https://vulnerable-website.com/login/sso'); 
}
```

This way, the `window.open()` method is only invoked when the user clicks somewhere on the page.

PoC
```html
<html>
  <body>
    <form id="csrfForm" action="https://0aaf002703aeedca80fb0386004f0089.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="hacker@evil-domain.com" />
    </form>
    
    <script>
      // 1. Trigger the social login to get a fresh session cookie.
      // We open it in a popup or use a temporary window so the script keeps running.
	    var promo;
	    window.onclick = () => { // You can use phishing "Click here to confirm you aren't a robot". Using hover won't work ;( .
		    promo = window.open('https://0aaf002703aeedca80fb0386004f0089.web-security-academy.net/social-login');
		}
	    // 2. Wait a short moment to ensure the cookie is set.
	    setTimeout(function() {
	        // 3. Close the login window (optional)
	        promo.close();
	        
	        // 4. Submit the form. 
	        // Because it's a top-level navigation and within the 2-minute window, 
	        // Chrome will include the "Lax" cookie in this POST request.
	        document.getElementById('csrfForm').submit();
	    }, 4000); // 4 second delay
    </script>
  </body>
</html>
```