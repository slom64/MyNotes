## Terminology
- Resource Owner: normal user who has the account
- Client: Application which want to access the user resources. "yelp.com"
- Authorization server: Server that the Resource owner put his credentials to prove he want to give permission to client to access his resource. "accounts.google.com"
- Resource server: Server that has API enable the client to access the users Resources
- Authorization Grant: the prove that the user has clicked 'yes' to grant access to client.
- Redirect URI "Call back": Where should the Authorization server redirect the user to the client application.
- Authorizatino code: its temperory code that is sent to the client after authorization grant, and it sent back to authrization server to get access token.
- Access Token: token that used to get access to resources on resource server.
- scope: what things the client wants to do. the authorization server has list of scopes `email: read,delete`, the cleint choose what it really needs, then the Authroization server show the user what things the client want to access

> [!Question] 
> Why do we need authorization code then get access token? why not using authroization code as access token directly?

Having the token stored in browser is very unsecure. so instead, the user give back the authorization code to client, which in the backend sends the authorization code to authorization server ,then  authorization server send back the token and client stores the token in database. all of that happens in the backend without the use of user browser.

The client sends authorization code + secret key (generated when client register for OAuth service in Authorization server) "Even if someone stole the authorization code, they can't get access token because they don't have the secret key that the server has got when registered it for OAuth service" 

---
## Common Query parameters
#### response_type
This query argument represent how the authorization server should response back:
- `code`: which mean the authorization server will send back authentication code that should be used alongside with the client secret key to get access token to get access to resources APIs.
- `token`:which is used in `'Implicit'` simple OAuth implementations. where the user get the token stored in browser and use this token to directly access resources using API's.
- `id_token`: which could be used to get JWT that has identity of the user.
#### Scope
This contain what resource the client want to have access to:
- `scope=openid`: This define that we want to use OpenID for authentication. if `response_type=code` we will get `JWT of identity` + `access token` when we talk back to authorization server, but if we have `response_type=id_token` we will get `JWT token` directly to browser "Used in debug". 
#### state 
```
state=random_string_here
```
- Prevents **CSRF attacks** on OAuth flow
- Client generates random string, stores it server-side
- Validates it matches when user returns
- If mismatch â†’ possible CSRF attack

---
## Oauth2 flow
### Pre-request
You should register your application to use OAuth service from google, and when we create client we get 2 things
1. client_id: This should be sent along every OAuth interaction from the user.
2. secret key: This should be hidden and used for validating the client by submitting it alongside with the authorization code to get access token.

---
### Flow
1. When you press on login with google we send the following request to authorization server.
```http
https://account.google.com/o/aoth2/v2/auth?
client_id=abc123& # This one used so authorization server can map the client_id with specific secret key.
redirect_uri=https://yelp.com/callback& # this where authorization server will redirect us after granting authorization.
scope=profile& # the requested resources by the client
response_type=code& # this could be code, token, 
state=foobar
```
2. We put our cerdentials and decide weather grand the clinet access to our resources then authorization server redirect us to the `redirect_uri` with query parameters:
```http
#
https://yelp.com/callback?state=foobar&code=ThisCodeWillBeReused # if we accept resource granting to client.
https://yelp.com/callback?error=access_denied&error_description=The user did not consent # if we reject granting resources.
```
3. The backend server exchange the code for access token.
```http
POST /OAuth/v4/token HTTP/1.1
Host: www.googleApis.com 
Content-type: application/x-www-form-urlencoded

code=ThisCodeWillBeReused&
client_id=abc123&
client_secret=secret123&
grant_type=authorization_code
```
response
```json
{
	"access_token" : "asdfkqwerupzokxcjv",
	"expires_in" : 3920,
	"token_type" : "Bearer",
}
```
4. Now the client has what it need to reach the resources using APIs calls that access_token included within them.
```http
GET /some/endpoint HTTP/1.1
Host: api.google.com
Authorization: Bearer asdfkqwerupzokxcjv
```

---

### OpenID

Standard OAuth2 protocol was built mainly for authorization, but many application start to use it for authentication. The problem here is that there is no way for the client to know the user identity using the standard OAuth2 protocol. So backend should do more additional requests and commands to fill the gap. Here the problem pops up because every developer may have his own way to retrive the use identity.

Here OpenID come as a solution for this problem, Its an extension over OAuth2. The main difference is `scope=openid`, which makes the authorization server response with access token +  JWT that contain the user identity

![[Z Assets/Images/Pasted image 20251222002550.jpeg]]

#### JWT token (ID)
```json
{
	"iss" : "https://accounts.google.com", // authorization server
	"sub" : "slom@gmail.com"                //email of the user
	"name": "slom km"
	"aud" : "asdfASE"
	"exp" : "1234"
	"iat" : "2234"
	"auth_time": 123455243,
}.
(signature)
```

The signature use Assymetric keys (Public-Private keys). So its signed using the authorization server private key, and the client can be valid it using the public key of the authorization server "Published at `/.well-known/jwks.json` endpoint" 