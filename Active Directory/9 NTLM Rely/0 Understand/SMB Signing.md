| **Target Service**   | **Protocol** | **Primary Relay Defense** | **Mechanism Name**                     |
| -------------------- | ------------ | ------------------------- | -------------------------------------- |
| **File Shares**      | SMB          | **Signature**             | SMB Signing                            |
| **Web / IIS / ADCS** | HTTP/S       | **Channel Binding**       | Extended Protection (EPA)              |
| **SQL Database**     | TDS (MSSQL)  | **Channel Binding**       | Extended Protection / Force Encryption |
| **Exchange**         | SMTP         | **Channel Binding**       | Extended Protection (EPA)              |
| **Active Directory** | LDAP (389)   | **Signature**             | LDAP Signing                           |
| **Active Directory** | LDAPS (636)  | **Channel Binding**       | LDAP Channel Binding                   |
| **WMI / DCOM**       | RPC          | **Signature**             | RPC Packet Integrity (Auth Level 5/6)  |

---
> [!Question] 
> what makes smb when signing is enabled not vulnerable to relay. what is the new thing that is added

That's a very focused and important question for the NTLM Relay module!

When **SMB Signing** (or Message Signing) is enabled, the new element that is introduced and fundamentally breaks the NTLM Relay attack chain is the **Message Signature** (or **MAC - Message Authentication Code**), which is calculated using a **Session Key**.

Here is a detailed breakdown of what is added and how it prevents the relay attack.
### 1. The New Element: The Session Key
SMB Signing is a security feature that uses a **Session Key** to create a cryptographic signature for every message.1
- **What is the Session Key?**
    - It's a temporary, secret, symmetric key.2
    - It is generated by the **Client** and the **Domain Controller (DC)** during the successful NTLM authentication exchange (the 3-way handshake).
    - Crucially, this key is derived from the **`Client's NTLM Password Hash`** and the **`Server's Challenge`**.
### 2. The New Process: Signing Every Message
When SMB Signing is enabled, every packet sent from the Client to the Server (and vice versa) gains a new field: the **Signature** or **MAC**.
1. Client's Action: For every message the Client sends (e.g., "Access this file"), the Client calculates a unique signature using:
 $$MAC = Hash(Session Key, Message Content, Message Sequence Number)$$
2. **Server's Action:** The Client then attaches this MAC to the message and sends it.
3. **Server's Verification:** When the Server receives the message, it performs the **exact same calculation** using its copy of the Session Key.
4. **Verification Check:**
    - If the Server's calculated MAC **matches** the MAC attached to the message, the message is considered authentic and is processed.
    - If they **do not match**, the message is rejected as tampered with, and the connection is dropped.
### 3. How This Stops the NTLM Relay Attack
In a classic NTLM Relay attack, the attacker (the relay machine) stands in the middle, intercepting the NTLM messages and forwarding them to the target server.3
#### A. Authentication is Successfully Relayed
The attacker can still successfully relay the **NEGOTIATE (Type 1)**, **CHALLENGE (Type 2)**, and **AUTHENTICATE (Type 3)** messages. The target server believes the attacker is the legitimate client and validates the credentials with the DC.

At the end of this successful authentication, the target server and the original client both successfully derive the **Session Key**.
#### B. The Attacker Does NOT Have the Key
The problem for the attacker is that the **Session Key is derived from the original user's NTLM Password Hash**, which was never sent over the wire. The attacker only sent the final hash response (the proof), but never the foundational secret (the password hash) required to generate the Session Key.

Therefore, the attacker has **NO ACCESS** to the Session Key.
#### C. The Attack Fails on the First Signed Command
1. After successful authentication, the Target Server immediately expects the first command (e.g., "Create a file on this share") to be **signed** using the new Session Key.
2. The Attacker (Relay) intercepts this command and attempts to send its _own_ malicious command (e.g., "Add a user to the Administrators group").
3. The Attacker **cannot** generate a valid MAC for this malicious command because it does not possess the Session Key.
4. When the Target Server receives the attacker's unsigned or improperly signed command, it rejects it immediately, dropping the connection and stopping the attack before any malicious action can be taken.
**In summary, SMB Signing forces the use of the Session Key for integrity protection, and since the NTLM Relay attacker does not have the Session Key, the attacker cannot successfully execute commands on the target server.**

---

> [!Question] 
> wait, if session key = NTLM hash of user + server challenge and client challenge is sent on wire
> why can't we combine things to gather to bypass the SMB signing

This is the central point of confusion when learning about NTLM Relay and SMB Signing, and it's where the specific mathematical properties of the NTLMv2 calculation provide protection.

The reason you **cannot** combine the components you captured to bypass SMB Signing is that the **Session Key** is generated from the **user's actual NTLM password hash**, which is the fundamental secret the attacker _never_ possesses.

Here is the step-by-step reason why the captured data is insufficient to derive the session key, thus defeating signing.

---

### 1. The Secrets You Have vs. The Secrets You Need

Let's clearly define what the attacker (Relay) has and what the attacker needs:

#### ðŸ”‘ What the Attacker **HAS** (Captured on the Wire):

1. **Server Challenge:** The random 8-byte nonce from the server.
2. **Client Challenge:** The timestamp and client nonce from the client.
3. **NTLMv2 Response (The "Proof"):** The final hash calculated by the client using the secret key.
4. **User/Domain:** The user's name and domain.
#### ðŸ”‘ What the Attacker **NEEDS** (The Foundational Secret):
- **The User's NTLM Password Hash ($\text{PWH}$):** The fixed, 16-byte hash of the user's password. This hash resides _only_ on the client machine (for calculation) and the Domain Controller (for storage/verification). **It is never transmitted in any form.**
### 2. The Calculation of the Session Key
The Session Key (used for SMB Signing) is derived from a key component that the attacker does not have: the $\text{PWH}$.
The calculation of the **Session Key** is based on the following formula (simplified for clarity):
$$\text{Session Key} = \text{HMAC-MD5} (\mathbf{\text{PWH}}, \text{NTLMv2 Response})$$

_Or, more specifically, the NTLM Hash ($\text{PWH}$) is used to key an HMAC calculation over the Session Key generated during the response._
### 3. Why the Captured Data Fails to Create the Key
You stated: "if session key = NTLM hash of user + server challenge."

**This formula is incorrect.**

If the attacker _knew_ the $\text{PWH}$, they could easily generate the Session Key, and SMB Signing would be useless. But because the attacker only has the **result** of the authentication ($\text{NTLMv2 Response}$), and not the **secret ingredient** ($\text{PWH}$), they are stuck.

| **If NTLM Signing is Enabled**  | **Why the Attacker Fails**                                                                                                                                             |
| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **To Sign a Message**           | The attacker needs the **Session Key**.                                                                                                                                |
| **To Generate the Session Key** | The attacker needs the **User's NTLM Password Hash** ($\text{PWH}$).                                                                                                   |
| **To Get the $\text{PWH}$**     | The attacker would have to **crack the captured hash** _first_.                                                                                                        |
| **The Result**                  | Since the attacker has not cracked the hash, they do not have the $\text{PWH}$, cannot generate the **Session Key**, and therefore cannot sign the malicious commands. |
### The Critical Takeaway: SMB Signing vs. Pass-The-Hash
The key distinction is between **using the _hash_ to prove identity** and **using the _key_ to sign messages.**
- **NTLM Relay (Unsigned):** Works because the target server only needs to see a **valid proof (the response)** from the client to grant access. The attacker relays the proof and gets access.
- **NTLM Relay (Signed):** Fails because, even if the attacker successfully relays the initial proof, the target server immediately demands that subsequent commands be secured with a **Session Key** that only the true owner of the $\text{PWH}$ can generate.

The attacker must successfully **crack the captured NTLMv2 hash** to obtain the $\text{PWH}$ _before_ they can generate the Session Key and bypass signing. If they can crack the hash, the attack moves from "Relay" to **"Pass-The-Hash/Key"** because they now possess the foundational secret.

---

> [!question] 
> when we are talking about ntlm relay, the  most important thing is the target service signing status not the incoming service signing status, so we can relay most ntlm authentication even if there is signing but the real problem is in the target service if it require signing or not, if it requires it then we can't do anything.


The golden rule of NTLM Relay is: **The vulnerability lies in the configuration of the TARGET, not the Victim.**
Here is the breakdown of why your statement is correct and the technical nuance behind it.
### 1. The Incoming Side (Victim $\rightarrow$ Attacker)

**Why Signing Doesn't Matter Here:**
When the victim connects to you (the attacker), they might be configured to "Require Signing."
- **The Relay Process:** You are simply forwarding their Type 1 message to the target, getting the Type 2 from the target, and handing it to the victim.
- **The Completion:** The victim generates the Type 3 (Proof) and sends it to you.
- **The Ignored Requirement:** Even if the victim _expects_ you to sign your response to them, **you don't care.** You have already received what you wanted: the valid Type 3 authentication message. You can simply drop the connection with the victim after you steal the credential blob. You don't need to maintain a signed session with the _victim_; you only need to establish one with the _target_.
### 2. The Target Side (Attacker $\rightarrow$ Target)
**Why Signing is the Dealbreaker:**
This is where the attack lives or dies. You are trying to execute a command (like `psexec` or dumping hashes) on the Target.
- **Scenario A: Target = Signing NOT Required (Vulnerable)**
    1. You forward the stolen Type 3 message to the target.
    2. Target accepts it. Authenticated!
    3. You send a malicious command (e.g., `remote execution`).
    4. **Success:** Since the target does **not** check for a signature, it executes the command based solely on the previous authentication.
- **Scenario B: Target = Signing Required (Secure)**
    1. You forward the stolen Type 3 message to the target.
    2. Target accepts it. Authenticated!
    3. **The Check:** The target now expects every packet to have a valid `MAC` signature.
    4. **The Failure:** As we discussed, you (the attacker) **do not have the Session Key** because you never cracked the password. You cannot calculate the correct `MAC`.
    5. You send your command (unsigned or invalidly signed).
    6. **Blocked:** The target drops the packet and kills the connection.
### âš¡ Summary
- **Client (Victim):** Can have "Signing Required." It doesn't stop us from stealing the Type 3 message.    
- **Server (Target):** If it has "Signing Required" (like a Domain Controller), the relay is **impossible**. If it has "Signing Disabled/Not Required," the relay **succeeds**.

This is why, in a penetration test, we scan the network specifically for machines where **"Message Signing is disabled"** (usually workstations) to use them as targets, while avoiding Domain Controllers (which require it by default).
