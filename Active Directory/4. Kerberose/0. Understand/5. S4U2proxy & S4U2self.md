
> [!Question] 
> i want more explanation about S4U2proxy and S4U2self. What does S4U2proxy actually look like as request? what i have understand is that when the user show his TGS for front-end service, and this service has constrained delegation to back-end service, So this front-end service take a copy of user TGS and send it to KDC to give back a forwardable TGS ticket that the service can use to access the back-end service.
> 
and for S4U2self As what i know S4U2self is used when we have NTLM authentication is enabled in delegation. So we don't have user TGS, so we need a way to get user TGS to use S4U2proxy extension. Here S4U2self comes in to get user TGS that would be used later to get forwardable ticket to access the back-end service

**In nutshell**:
- If the user use NTLM or certificate (non-kerberos) authentication, then the service use its own TGT to do TGS-REQ on behalf of the user to KDC for its own to read user authorization data. But if user used kerberos then the TGS that the user use is already set as forwardable from the KDC from the first place.
- Now the service has forwardable TGS, the service do another special TGS-REQ to KDC with the forwardable TGS, then KDC give back TGS ticket for the service that can be used on behalf of the user.
- Now the service can access the back-end service.
---
# Detailed Explanation of S4U2self and S4U2proxy

Your understanding is close but has a few inaccuracies that I'll correct while expanding on the concepts. These are Microsoft extensions to the Kerberos protocol (documented in [MS-SFU]), primarily used in Active Directory environments to support constrained delegation and protocol transition. They allow a front-end service (e.g., a web server) to impersonate a user when accessing a back-end service (e.g., a database) without requiring the user's full Ticket-Granting Ticket (TGT) to be forwarded, which reduces security risks compared to unconstrained delegation. I'll break this down step by step, including how they work together, the request structures (based on Kerberos messages like KRB_TGS_REQ), and corrections to your points.

---
## S4U2self: Obtaining a Ticket to "Self" on Behalf of a User
S4U2self (Service for User to Self) allows a service to request a service ticket (often called a TGS ticket) **to itself** on behalf of a user. This is crucial for scenarios where the user didn't authenticate using Kerberos—such as when NTLM, certificate-based, or other non-Kerberos methods are used (e.g., a user logs into a web app via forms authentication). Without this, the service wouldn't have the user's Kerberos identity or authorization data (like group memberships in a Privilege Attribute Certificate, or PAC).

**Key Corrections to Your Understanding**:
- Yes, S4U2self is often used in protocol transition (e.g., converting NTLM auth to Kerberos for delegation), but it's not solely for getting a "user TGS" in the sense of the user's own ticket. Instead, it generates a forwardable service ticket **to the requesting service itself** (not a general TGS for arbitrary services). This ticket includes the user's identity and authorization data, allowing the service to make decisions as if Kerberos auth had occurred.
- The resulting ticket is marked as forwardable (via the forwardable flag in the ticket), which is essential for chaining to S4U2proxy later. However, this ticket can't be used directly to access other services—it's only for the service's own use or as "evidence" in delegation.
- Preconditions: The service must have its own TGT (from authenticating to the KDC) and be configured with the `TRUSTED_TO_AUTH_FOR_DELEGATION` flag in its UserAccountControl attribute (for forwardable tickets). No user password is needed; the KDC trusts the service based on its configuration.

**What Does an S4U2self Request Look Like?**
S4U2self is implemented as a modified KRB_TGS_REQ message sent to the KDC (Ticket Granting Service, or TGS component). It's not a "copy" of anything—it's a new request from the service. Here's a high-level structure (based on RFC 4120 for Kerberos, extended in [MS-SFU]):

- **Message Type**: KRB_TGS_REQ (standard Kerberos request for a service ticket).
- **Key Extensions**:
  - **padata Field**: Contains the S4U2self-specific data, such as PA-FOR-USER (a structure identifying the user by name and realm) or PA-S4U-X509-USER (if using a user certificate for identification).
  - **Options**: Includes the forwardable flag to request a forwardable ticket.
  - **cname and crealm**: Specifies the user being impersonated (not the service).
  - **sname and srealm**: Set to the service's own principal (e.g., the front-end service's SPN).
- **Authenticator**: Encrypted with the service's session key (from its TGT).
- **No Additional Tickets**: Unlike S4U2proxy, this doesn't require an evidence ticket.

The KDC responds with a KRB_TGS_REP containing the service ticket to the front-end service, addressed as if the user had requested it themselves. This ticket includes the user's PAC (authorization data) and is forwardable. In tools like Rubeus (for testing), this might look like: `rubeus.exe s4u /user:targetuser /msdsspn:HTTP/frontend.contoso.com` (which internally sends the KRB_TGS_REQ).

**Flow Example**:
1. User authenticates to front-end service via NTLM.
2. Front-end sends KRB_TGS_REQ with S4U2self extensions to KDC.
3. KDC verifies the service's permissions and issues a forwardable service ticket to the front-end (on behalf of the user).
4. Front-end uses this for local authorization or passes it to S4U2proxy.

---
## S4U2proxy: Requesting a Ticket to Another Service on Behalf of a User
S4U2proxy (Service for User to Proxy) builds on S4U2self or a user's provided ticket, allowing the front-end service to request a service ticket **to a back-end service** on behalf of the user. This is the core of constrained delegation, where the impersonation is limited to specific back-end SPNs listed in the front-end account's `msDS-AllowedToDelegateTo` attribute.

**Key Corrections to Your Understanding**:
- It's not about "taking a copy of the user's TGS and sending it to the KDC." If the user authenticated with Kerberos, they provide a forwardable TGS ticket to the front-end (via KRB_AP_REQ). For non-Kerberos auth (like NTLM), S4U2self first generates that forwardable ticket. Then, S4U2proxy uses this "evidence ticket" to request a new TGS to the back-end.
- The KDC checks the evidence ticket's PAC (if present) for validity and copies the user's authorization data to the new ticket. The resulting ticket has the user's identity (cname/crealm), not the front-end's, allowing true impersonation.
- For RBCD (resource-based), the check is on the back-end's `msDS-AllowedToActOnBehalfOfOtherIdentity` instead, and a forwardable evidence ticket isn't strictly required.

**What Does an S4U2proxy Request Look Like?**
Like S4U2self, it's a KRB_TGS_REQ message, but with additional fields for delegation. High-level structure:

- **Message Type**: KRB_TGS_REQ.
- **Key Extensions**:
  - **padata Field**: Includes PA-S4U2proxy (specifying the proxy details) and may reference the user's PAC for validation.
  - **additional-tickets Field**: Contains the "evidence ticket" (the forwardable TGS from the user or S4U2self).
  - **cname and crealm**: The impersonated user's identity.
  - **sname and srealm**: The back-end service's SPN (e.g., CIFS/backend.contoso.com).
  - **Options**: Forwardable flag is typically set.
- **Authenticator**: From the front-end service's session key.

The KDC validates:
- The evidence ticket is forwardable.
- The back-end SPN is in the allowed list (`msDS-AllowedToDelegateTo` for constrained).
- PAC signature (if present).

Response: KRB_TGS_REP with the new service ticket to the back-end, under the user's identity. In practice (e.g., with Rubeus): `rubeus.exe s4u /ticket:base64evidenceticket /msdsspn:CIFS/backend /ptt` (sends KRB_TGS_REQ and injects the result).

**Combined Flow in Constrained Delegation (NTLM Case)**:
1. User authenticates to front-end via NTLM (no Kerberos ticket provided).
2. Front-end uses S4U2self (KRB_TGS_REQ) to get forwardable ticket to self on behalf of user.
3. Front-end uses S4U2proxy (another KRB_TGS_REQ with evidence ticket) to get ticket to back-end.
4. Front-end presents the back-end ticket (via KRB_AP_REQ) to access the resource as the user.

These extensions enhance security by limiting scope but can be abused (e.g., for privilege escalation if the front-end is compromised). Mitigate with proper configs like Protected Users groups. If you need code examples or tool demos, let me know!

---
### Subject: 1.26. What are forwardable tickets?

Inside of the Kerberos ticket is encoded the IP address of the client. This is used by [application servers](https://web.archive.org/web/20180726073615/https://www.di-srv.unisa.it/~ads/corso-security/www/CORSO-0001/kerberos/ref/kerberos-faq.html#servers) and the [KDC](https://web.archive.org/web/20180726073615/https://www.di-srv.unisa.it/~ads/corso-security/www/CORSO-0001/kerberos/ref/kerberos-faq.html#servers) to verify the address of the client. This means that a ticket that was acquired on one host cannot be used on another.

Kerberos 5 introduced the concept of **forwardable** tickets. During the initial [TGT](https://web.archive.org/web/20180726073615/https://www.di-srv.unisa.it/~ads/corso-security/www/CORSO-0001/kerberos/ref/kerberos-faq.html#tgttgs) acquisition, a client can request that the ticket be marked forwardable. If the KDC chooses to honor this request (the administrator has the option of disallowing forwardable tickets on a per-site or per-principal basis), the TKT_FLG_FORWARDABLE flag will be set in the flags field in the ticket.

Once the TKT_FLG_FORWARDABLE flag is set on a ticket, the user can use this ticket to request a **new** ticket, but with a different IP address. Thus, a user can use their current credentials to get credentials valid on another machine.

In the MIT Kerberos 5 release, all of the remote login programs (telnet, rlogin, rsh) support forwarding a user's TGT to the remote system.

------------------------------------------------------------
### Subject: 1.27. What are renewable tickets?

One practical problem with Kerberos is that the tickets eventually expire. A practical balance has to be made between the desire to reduce the usefulness of stolen tickets (short lifetime) versus the ease-of-use for the user (long lifetime).

This problem becomes a much larger issue when dealing with long-running user processes. Jobs run on some supercomputer systems can run for days or weeks, but having tickets that last that long can be a security nightmare.

The compromise for this problem that was introduced in Kerberos 5 is the support for **renewable** tickets. Renewable tickets have expiration times, like normal tickets. However, they also have a _maximum renewable lifetime_.

A renewable ticket can be renewed by asking the KDC for a new ticket with an extended lifetime. However, the ticket itself has to be valid (in other words, you cannot renew a ticket that has expired; you have to renew it before it expires). A renewable ticket can be renewed up until the maximum renewable ticket lifetime.

This scheme has two important advantages over long-lived tickets:
1. It reduces the window of usefulness for stolen tickets. If an attacker gets access to a renewable ticket after it has expired, then it is useless.
2. After a user is finished with a renewable ticket, he can notify the KDC that he no longer needs the ticket, and the KDC will refuse to renew this ticket any more (note that although this is in the protocol, I don't think any version of Kerberos actually implements this part).
