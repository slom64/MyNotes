### Introduction to Kerberos Delegation in Active Directory

Kerberos delegation is a mechanism in Windows Active Directory that allows a front-end service (e.g., a web application) to impersonate an authenticated user when accessing a back-end service (e.g., a database or file share) on the user's behalf. This is essential for multi-tier applications where the front-end needs to pass the user's identity to subsequent services without requiring the user to re-authenticate. Delegation relies on Kerberos tickets and is configured via attributes on Active Directory objects, such as user or computer accounts. There are three main types: unconstrained, constrained, and resource-based constrained delegation (RBCD). Constrained types use Microsoft extensions called Service for User (S4U), specifically S4U2self and S4U2proxy, to enable secure impersonation. Delegation can fail if the user has protections like the "Account is sensitive and cannot be delegated" flag or membership in the Protected Users group. While useful, delegation introduces security risks, as compromising a delegated service can lead to privilege escalation.

---
### Unconstrained Delegation

Unconstrained delegation is the simplest and least secure form, allowing a service to impersonate a user to **any** other service in the domain without restrictions. It is enabled by setting the `TRUSTED_FOR_DELEGATION` flag (bit 0x80000 in UserAccountControl) on the service account's AD object, which requires the `SeEnableDelegationPrivilege` (typically held by domain admins).

**How It Works**:
- When a user authenticates to the front-end service (via a Ticket-Granting Service or TGS ticket), the Key Distribution Center (KDC) includes the user's full Ticket-Granting Ticket (TGT) in the TGS if the service is trusted for unconstrained delegation.
- The front-end service extracts the user's TGT (encrypted with its own key) and uses it to request TGS tickets for any back-end service as the user.
- This effectively gives the service the user's full domain privileges for delegation.

**Key Differences**: Unlike constrained types, there are no whitelists limiting target services, making it broad but risky. It's a legacy feature, often misconfigured in older environments.

**Security Implications and Abuse**:
- If an attacker compromises the front-end service or its host, they can harvest TGTs from memory or logs, enabling pass-the-ticket attacks to impersonate users anywhere.
- Attackers can coerce privileged users (e.g., domain admins) to authenticate to the service, stealing their TGT for domain compromise.
- For persistence, attackers may enable unconstrained delegation on controlled accounts.
- Microsoft recommends avoiding it in favor of constrained options due to its exposure.

---
### Constrained Delegation

Constrained delegation restricts impersonation to a predefined list of back-end services, making it more secure than unconstrained. It is enabled by setting the `TRUSTED_TO_AUTH_FOR_DELEGATION` flag (bit 0x1000000 in UserAccountControl) on the front-end service account and populating the `msDS-AllowedToDelegateTo` attribute with target Service Principal Names (SPNs). Configuration requires `SeEnableDelegationPrivilege`.

**How It Works**:
- Relies on S4U extensions (detailed below) to obtain tickets without the user's full TGT.
- The front-end service uses S4U2self to get a ticket to itself on behalf of the user, then S4U2proxy to request a ticket to a whitelisted back-end service.
- The KDC checks the whitelist and ensures the input ticket is forwardable before issuing the new ticket.
- Supports "Kerberos-only" mode (limits to Kerberos authentication) or "any protocol" (enables protocol transition for non-Kerberos auth like NTLM).

**Key Differences**: Limits scope to specific SPNs, reducing attack surface compared to unconstrained. Unlike RBCD, the delegation trust is configured on the front-end (impersonator) side, requiring higher privileges to set up.

**Security Implications and Abuse**:
- Safer, but if compromised, attackers can abuse the whitelist to access listed services as any user.
- A common exploit involves modifying the cleartext service name in a TGS ticket to target non-whitelisted services owned by the same account (since they share encryption keys).
- With protocol transition enabled, attackers can impersonate users without their credentials, leading to local privilege escalation or lateral movement.

---
### Resource-Based Constrained Delegation (RBCD)

RBCD flips the trust model of traditional constrained delegation: instead of configuring delegation on the front-end service, the back-end resource decides which services can impersonate users to it. Introduced in Windows Server 2012, it uses the `msDS-AllowedToActOnBehalfOfOtherIdentity` attribute on the target account, which can be set by the resource owner (no domain admin privileges needed).

**How It Works**:
- The front-end service (impersonator) uses S4U2self to obtain a forwardable ticket to itself on behalf of the user.
- It then uses S4U2proxy to request a ticket to the back-end service; the KDC checks if the impersonator is listed in the target's `msDS-AllowedToActOnBehalfOfOtherIdentity` (a security descriptor allowing specific principals).
- Unlike constrained delegation, the input ticket doesn't need to be forwardable for RBCD approval.

**Key Differences**: Trust is resource-centric, making it easier to manage in large environments (e.g., for clustered services). It requires lower privileges to configure and supports multi-host scenarios. If both constrained and RBCD apply, constrained takes precedence.

**Security Implications and Abuse**:
- Attackers with control over a low-privilege account can configure RBCD to allow delegation from that account to high-value targets, chaining S4U to impersonate users.
- For example, setting RBCD to the krbtgt account enables forging TGTs (similar to a Golden Ticket) for arbitrary users, leading to domain persistence.
- It's often abused for privilege escalation in red team scenarios, as it doesn't require the high privileges of other delegations.

---
### S4U2Proxy and S4U2Self Extensions

These are Kerberos protocol extensions (Service for User, or S4U) that power constrained delegation and RBCD, allowing services to request tickets without the user's password or full TGT.

**S4U2Proxy (Service for User to Proxy)**:
- Enables a front-end service to request a TGS ticket to a back-end service on behalf of a user, using a forwardable ticket (from the user or S4U2self) as evidence.
- The KDC validates against whitelists (`msDS-AllowedToDelegateTo` for constrained, `msDS-AllowedToActOnBehalfOfOtherIdentity` for RBCD) and always issues forwardable tickets if approved.
- Requirements: The service must own SPNs; for constrained, the input ticket must be forwardable (not required for RBCD).
- Abuse: Modify service names in tickets to bypass whitelists for services sharing keys; used in chains for impersonation.

**S4U2Self (Service for User to Self)**:
- Allows a service to request a TGS ticket to **itself** on behalf of a user, facilitating protocol transition (e.g., converting NTLM auth to Kerberos).
- The KDC checks if the service owns SPNs and has the `TRUSTED_TO_AUTH_FOR_DELEGATION` flag (for forwardable tickets); otherwise, it issues non-forwardable tickets.
- Often chained with S4U2proxy: Get a self-ticket as the user, then proxy to the back-end.
- Abuse: Enables impersonation without user credentials, useful for local escalation (e.g., forging admin tickets) or stealthy silver ticket alternatives.

These extensions make delegation flexible but exploitable if misconfigured. For mitigation, regularly audit delegation settings, use Protected Users groups, and prefer RBCD over unconstrained.