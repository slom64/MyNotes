Lets talk about using asymmetric key ( public / private ) infrastructure in web so we can sense where the problem pops up.
When the client wants to talk to server it first tries to get the server public key to be used in communication between server and client, Now here the attacker may intercept the request and sends its own public key and do MITM attack between the client and server, So we need a solution that guarantee that the client will take the server public key.

Here the certificate authority comes into play, When the cleint asks the server for its public key. the server goes to the certificate authority asking to sign the server public key, all what the CA does is making a certificate that contain `issued to (subject)` , `issued from (issuer)` , `public key` of the server, `server public key + CA private key = Signed public key ( Encrypted server public key)` then give it back the server that give it back the client, now the client should have the CA public key as trusted CA (trust the public key of the CA), then use that public key to decrypt the signed data, when the client decrypt the signed data he can validate weather the server public key have been tampered or not.

Even if attacker has intercepted the request and sent fake public key and signed it, the client doesn't trust the attacker public key so it won't be able to decrypt the data. That makes the client reject the certificate.
![[Z Assets/Images/Pasted image 20251201125456.jpeg]]



# Chain trust
![[Z Assets/Images/Pasted image 20251201123857.jpeg]]

The root certificate is very high value, So the root CA should always has high level of protection, thats why we use the intermediate CAs. 

> [!NOTE] 
> As what I have read, Root CA servers are shutdown so they don't get compremised and steal their private keys

When the client gets the server certificate it looks who is the issuer the one who signed the certificate with its private key and he will find it is intermediate CA so the client decrypt the server certificate using the intermediate CA public key, now when we want to get the public key of the intermediate CA we will get another certificate which is the intermediate certificate that is signed by the root CA private key, and we can validate it by the root CA public key.

Thats the whole chain should be validated.

> [!Attention] 
> Browsers and copmuters stores the root CAs only. The intermediate CAs aren't stored, which is good because if intermediate CA private key got stolen then intermediate CA companies can just create new public private keys.
